#!/usr/bin/env python3
"""
Package Vulnerability Scanner CLI Tool
A tool to check package versions from Chainguard and GitHub, and scan for CVE vulnerabilities.
"""

import os
import sys
import json
import argparse
import requests
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from urllib.parse import urlparse
import re

@dataclass
class PackageInfo:
    """Data class to hold package information"""
    name: str
    chainguard_version: Optional[str] = None
    github_version: Optional[str] = None
    github_repo: Optional[str] = None
    vulnerabilities: List[Dict] = None

    def __post_init__(self):
        if self.vulnerabilities is None:
            self.vulnerabilities = []

class PackageScanner:
    """Main package scanner class"""

    def __init__(self, github_token: Optional[str] = None, nvd_api_key: Optional[str] = None):
        self.github_token = github_token
        self.nvd_api_key = nvd_api_key
        self.session = requests.Session()

        # Set up headers for GitHub API
        if github_token:
            self.session.headers.update({
                'Authorization': f'Bearer {github_token}',
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28'
            })

    def get_chainguard_version(self, package_name: str) -> Optional[str]:
        """
        Get the latest version of a package from Chainguard registry
        """
        try:
            # Try to get registry token for the image
            token_url = f"https://cgr.dev/token?scope=repository:chainguard/{package_name}:pull"

            print(f"  ğŸ” Checking Chainguard registry for {package_name}...")

            token_response = self.session.get(token_url)
            if token_response.status_code != 200:
                print(f"    âŒ Could not get token for {package_name}")
                return None

            token_data = token_response.json()
            auth_token = token_data.get('token')

            if not auth_token:
                print(f"    âŒ No token received for {package_name}")
                return None

            # Get image tags using the Docker Registry API
            tags_url = f"https://cgr.dev/v2/chainguard/{package_name}/tags/list"
            headers = {'Authorization': f'Bearer {auth_token}'}

            tags_response = self.session.get(tags_url, headers=headers)

            if tags_response.status_code == 200:
                tags_data = tags_response.json()
                tags = tags_data.get('tags', [])

                if tags:
                    # Filter out dev tags and find latest
                    production_tags = [tag for tag in tags if not tag.endswith('-dev')]
                    if production_tags:
                        # Return the first production tag (usually 'latest')
                        latest_tag = production_tags[0] if 'latest' in production_tags else production_tags[0]
                        print(f"    âœ… Found Chainguard version: {latest_tag}")
                        return latest_tag
                    else:
                        latest_tag = tags[0]
                        print(f"    âœ… Found Chainguard version: {latest_tag}")
                        return latest_tag

            print(f"    âŒ No tags found for {package_name}")
            return None

        except Exception as e:
            print(f"    âŒ Error getting Chainguard version: {str(e)}")
            return None

    def find_github_repo(self, package_name: str) -> Optional[str]:
        """
        Find the GitHub repository for a package
        """
        try:
            print(f"  ğŸ” Searching GitHub for {package_name}...")

            # Search for repositories
            search_url = f"https://api.github.com/search/repositories"
            params = {
                'q': f'{package_name} in:name',
                'sort': 'stars',
                'order': 'desc',
                'per_page': 5
            }

            response = self.session.get(search_url, params=params)

            if response.status_code == 200:
                data = response.json()
                repos = data.get('items', [])

                if repos:
                    # Return the most starred repo that matches
                    for repo in repos:
                        if repo['name'].lower() == package_name.lower():
                            repo_full_name = repo['full_name']
                            print(f"    âœ… Found GitHub repo: {repo_full_name}")
                            return repo_full_name

                    # If no exact match, return the first result
                    repo_full_name = repos[0]['full_name']
                    print(f"    âœ… Found GitHub repo (best match): {repo_full_name}")
                    return repo_full_name

            print(f"    âŒ No GitHub repo found for {package_name}")
            return None

        except Exception as e:
            print(f"    âŒ Error finding GitHub repo: {str(e)}")
            return None

    def get_github_version(self, repo_full_name: str) -> Optional[str]:
        """
        Get the latest release version from GitHub
        """
        try:
            print(f"  ğŸ” Getting latest release for {repo_full_name}...")

            # Get latest release
            release_url = f"https://api.github.com/repos/{repo_full_name}/releases/latest"

            response = self.session.get(release_url)

            if response.status_code == 200:
                release_data = response.json()
                tag_name = release_data.get('tag_name', '')

                if tag_name:
                    print(f"    âœ… Found GitHub version: {tag_name}")
                    return tag_name

            # If no releases, try to get tags
            tags_url = f"https://api.github.com/repos/{repo_full_name}/tags"
            response = self.session.get(tags_url)

            if response.status_code == 200:
                tags_data = response.json()
                if tags_data:
                    latest_tag = tags_data[0]['name']
                    print(f"    âœ… Found GitHub tag: {latest_tag}")
                    return latest_tag

            print(f"    âŒ No releases or tags found for {repo_full_name}")
            return None

        except Exception as e:
            print(f"    âŒ Error getting GitHub version: {str(e)}")
            return None

    def search_vulnerabilities(self, package_name: str) -> List[Dict]:
        """
        Search for vulnerabilities using NVD API
        """
        try:
            print(f"  ğŸ” Searching for vulnerabilities in {package_name}...")

            # Use NVD API to search for CVEs
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                'keywordSearch': package_name,
                'resultsPerPage': 10
            }

            headers = {}
            if self.nvd_api_key:
                headers['apiKey'] = self.nvd_api_key

            response = self.session.get(base_url, params=params, headers=headers)

            # Rate limiting for NVD API
            time.sleep(1)  # Basic rate limiting

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = data.get('vulnerabilities', [])

                processed_vulns = []
                for vuln in vulnerabilities[:5]:  # Limit to top 5
                    cve_item = vuln.get('cve', {})
                    cve_id = cve_item.get('id', '')

                    description = ''
                    descriptions = cve_item.get('descriptions', [])
                    if descriptions:
                        description = descriptions[0].get('value', '')

                    # Get CVSS score and severity
                    metrics = cve_item.get('metrics', {})
                    severity = 'Unknown'
                    score = 'N/A'

                    if 'cvssMetricV31' in metrics:
                        cvss_data = metrics['cvssMetricV31'][0].get('cvssData', {})
                        severity = cvss_data.get('baseSeverity', 'Unknown')
                        score = cvss_data.get('baseScore', 'N/A')
                    elif 'cvssMetricV30' in metrics:
                        cvss_data = metrics['cvssMetricV30'][0].get('cvssData', {})
                        severity = cvss_data.get('baseSeverity', 'Unknown')
                        score = cvss_data.get('baseScore', 'N/A')
                    elif 'cvssMetricV2' in metrics:
                        cvss_data = metrics['cvssMetricV2'][0].get('cvssData', {})
                        score = cvss_data.get('baseScore', 'N/A')
                        # Convert v2 score to severity
                        if isinstance(score, (int, float)):
                            if score >= 9.0:
                                severity = 'CRITICAL'
                            elif score >= 7.0:
                                severity = 'HIGH'
                            elif score >= 4.0:
                                severity = 'MEDIUM'
                            else:
                                severity = 'LOW'

                    processed_vulns.append({
                        'cve_id': cve_id,
                        'severity': severity,
                        'score': score,
                        'description': description[:200] + '...' if len(description) > 200 else description
                    })

                if processed_vulns:
                    print(f"    âš ï¸  Found {len(processed_vulns)} vulnerabilities")
                else:
                    print(f"    âœ… No vulnerabilities found")

                return processed_vulns

        except Exception as e:
            print(f"    âŒ Error searching vulnerabilities: {str(e)}")
            return []

    def scan_package(self, package_name: str) -> PackageInfo:
        """
        Scan a single package for versions and vulnerabilities
        """
        print(f"\nğŸ“¦ Scanning package: {package_name}")
        print("=" * 50)

        package_info = PackageInfo(name=package_name)

        # Get Chainguard version
        package_info.chainguard_version = self.get_chainguard_version(package_name)

        # Find GitHub repo and get version
        github_repo = self.find_github_repo(package_name)
        if github_repo:
            package_info.github_repo = github_repo
            package_info.github_version = self.get_github_version(github_repo)

        # Search for vulnerabilities
        package_info.vulnerabilities = self.search_vulnerabilities(package_name)

        return package_info

    def scan_packages_from_file(self, file_path: str) -> List[PackageInfo]:
        """
        Scan packages listed in a file
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Package file not found: {file_path}")

        packages = []
        with open(file_path, 'r') as f:
            for line in f:
                package = line.strip()
                if package and not package.startswith('#'):
                    packages.append(package)

        if not packages:
            raise ValueError("No packages found in file")

        print(f"ğŸ“‹ Found {len(packages)} packages to scan\n")

        results = []
        for package in packages:
            try:
                result = self.scan_package(package)
                results.append(result)
            except Exception as e:
                print(f"âŒ Error scanning {package}: {str(e)}")
                # Add failed package with error info
                failed_package = PackageInfo(name=package)
                results.append(failed_package)

        return results

def print_results(results: List[PackageInfo]):
    """
    Print scan results in a formatted way
    """
    print("\n" + "=" * 80)
    print("ğŸ“Š SCAN RESULTS SUMMARY")
    print("=" * 80)

    for package in results:
        print(f"\nğŸ“¦ Package: {package.name}")
        print("-" * 40)

        print(f"ğŸ·ï¸  Chainguard Version: {package.chainguard_version or 'Not found'}")

        if package.github_repo:
            print(f"ğŸ™ GitHub Repository: {package.github_repo}")
            print(f"ğŸ·ï¸  GitHub Version: {package.github_version or 'Not found'}")
        else:
            print("ğŸ™ GitHub Repository: Not found")

        if package.vulnerabilities:
            print(f"\nâš ï¸  Vulnerabilities ({len(package.vulnerabilities)} found):")
            for vuln in package.vulnerabilities:
                severity_emoji = {
                    'CRITICAL': 'ğŸ”´',
                    'HIGH': 'ğŸŸ ', 
                    'MEDIUM': 'ğŸŸ¡',
                    'LOW': 'ğŸŸ¢'
                }.get(vuln['severity'], 'âšª')

                print(f"   {severity_emoji} {vuln['cve_id']} - {vuln['severity']} (Score: {vuln['score']})")
                print(f"      Description: {vuln['description']}")
        else:
            print("\nâœ… No vulnerabilities found")

def save_results_json(results: List[PackageInfo], output_file: str):
    """
    Save results to JSON file
    """
    output_data = []
    for package in results:
        package_dict = {
            'name': package.name,
            'chainguard_version': package.chainguard_version,
            'github_repo': package.github_repo,
            'github_version': package.github_version,
            'vulnerabilities': package.vulnerabilities
        }
        output_data.append(package_dict)

    with open(output_file, 'w') as f:
        json.dump(output_data, f, indent=2)

    print(f"\nğŸ’¾ Results saved to: {output_file}")

def main():
    """
    Main CLI function
    """
    parser = argparse.ArgumentParser(
        description="Package Vulnerability Scanner - Compare Chainguard and GitHub versions, check for CVEs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -f packages.txt
  %(prog)s -f packages.txt -o results.json
  %(prog)s -f packages.txt --github-token YOUR_TOKEN
  %(prog)s -f packages.txt --nvd-api-key YOUR_KEY
        """
    )

    parser.add_argument(
        '-f', '--file',
        required=True,
        help='Path to file containing package names (one per line)'
    )

    parser.add_argument(
        '-o', '--output',
        help='Output file to save results in JSON format'
    )

    parser.add_argument(
        '--github-token',
        help='GitHub personal access token for API requests'
    )

    parser.add_argument(
        '--nvd-api-key', 
        help='NVD API key for faster vulnerability scanning'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='Package Vulnerability Scanner 1.0.0'
    )

    args = parser.parse_args()

    # Get tokens from environment if not provided
    github_token = args.github_token or os.getenv('GITHUB_TOKEN')
    nvd_api_key = args.nvd_api_key or os.getenv('NVD_API_KEY')

    print("ğŸš€ Package Vulnerability Scanner")
    print("=" * 40)

    if github_token:
        print("âœ… GitHub token provided - API rate limits increased")
    else:
        print("âš ï¸  No GitHub token - API requests limited")

    if nvd_api_key:
        print("âœ… NVD API key provided - faster vulnerability scanning")
    else:
        print("âš ï¸  No NVD API key - slower vulnerability scanning")

    try:
        scanner = PackageScanner(github_token=github_token, nvd_api_key=nvd_api_key)
        results = scanner.scan_packages_from_file(args.file)

        print_results(results)

        if args.output:
            save_results_json(results, args.output)

        print("\nâœ… Scan completed successfully!")

    except FileNotFoundError as e:
        print(f"âŒ Error: {e}")
        sys.exit(1)
    except ValueError as e:
        print(f"âŒ Error: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nâ¹ï¸  Scan interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"âŒ Unexpected error: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
