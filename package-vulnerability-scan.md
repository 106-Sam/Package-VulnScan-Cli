# Package Vulnerability Scanner Python Script

Based on your requirements, I've created a comprehensive Package Vulnerability Scanner Python script that:

1. Checks package versions from official GitHub and ArtifactHub.io
2. Provides Chainguard versions if available
3. Checks for vulnerabilities and reports them
4. Downloads the latest version to `/tmp` directory
5. Scans it with Trivy and outputs results to `<package>-trivy.txt`
6. Cleans up temporary files after scanning

## Script Implementation

```python
#!/usr/bin/env python3
"""
Package Vulnerability Scanner

This script checks for the latest version of a package from:
1. Official GitHub repository
2. Official ArtifactHub.io
3. Chainguard registry

It then downloads the latest version to /tmp directory,
scans it with Trivy for vulnerabilities,
outputs the results to <package>-trivy.txt,
and cleans up the temporary files.
"""

import os
import sys
import json
import shutil
import logging
import tempfile
import subprocess
import requests
import tarfile
import argparse
from pathlib import Path
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class PackageScanner:
    def __init__(self, package_file=None, package=None):
        self.package_file = package_file
        self.package = package
        self.tmp_dir = None
        
    def check_dependencies(self):
        """Check if required dependencies are available."""
        dependencies = ['trivy']
        missing = []
        
        for dep in dependencies:
            try:
                subprocess.run(
                    [dep, '--version'], 
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.PIPE, 
                    check=True
                )
            except (subprocess.SubprocessError, FileNotFoundError):
                missing.append(dep)
        
        if missing:
            logger.error(f"Missing dependencies: {', '.join(missing)}")
            logger.error("Please install the required dependencies and try again.")
            return False
        return True
    
    def parse_package_file(self):
        """Parse package file and return list of packages."""
        if not self.package_file:
            return []
            
        packages = []
        try:
            with open(self.package_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    # Skip empty lines and comments
                    if line and not line.startswith('#'):
                        packages.append(line)
            return packages
        except Exception as e:
            logger.error(f"Error parsing package file: {e}")
            return []
    
    def get_github_latest_version(self, repo_owner, repo_name):
        """Get the latest version of a package from GitHub."""
        try:
            url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/releases/latest"
            response = requests.get(url)
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'version': data.get('tag_name', ''),
                    'published_at': data.get('published_at', ''),
                    'html_url': data.get('html_url', '')
                }
            elif response.status_code == 404:
                # Try to get the default branch to see if repo exists
                repo_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}"
                repo_response = requests.get(repo_url)
                
                if repo_response.status_code == 200:
                    logger.warning(f"Repository exists but no releases found for {repo_owner}/{repo_name}")
                    return {'version': None, 'published_at': None, 'html_url': None}
                else:
                    logger.error(f"Repository not found: {repo_owner}/{repo_name}")
                    return None
            else:
                logger.error(f"Failed to get latest version from GitHub: {response.status_code}")
                return None
        except Exception as e:
            logger.error(f"Error while getting GitHub version: {e}")
            return None
    
    def get_artifacthub_version(self, package_name):
        """Get the latest version of a package from ArtifactHub.io."""
        try:
            # Search for the package
            search_url = f"https://artifacthub.io/api/v1/packages/search?limit=20&offset=0&kind=0&ts_query={package_name}"
            search_response = requests.get(search_url)
            
            if search_response.status_code != 200:
                logger.error(f"Failed to search package on ArtifactHub: {search_response.status_code}")
                return None
                
            search_data = search_response.json()
            packages = search_data.get('packages', [])
            
            if not packages:
                logger.warning(f"No packages found on ArtifactHub for {package_name}")
                return None
                
            # Find the exact package match or closest match
            matched_package = None
            for pkg in packages:
                if pkg['name'].lower() == package_name.lower():
                    matched_package = pkg
                    break
            
            if not matched_package and packages:
                # Take the first result if no exact match
                matched_package = packages[0]
                
            if matched_package:
                return {
                    'version': matched_package.get('version', ''),
                    'app_version': matched_package.get('app_version', ''),
                    'repository': matched_package.get('repository', {}).get('name', '')
                }
            return None
        except Exception as e:
            logger.error(f"Error while getting ArtifactHub version: {e}")
            return None
    
    def get_chainguard_version(self, package_name):
        """Get the latest version of a package from Chainguard."""
        try:
            # Try to normalize package name for Chainguard
            chainguard_pkg = package_name.lower().replace('_', '-')
            
            # Get auth token for Chainguard registry
            token_url = f"https://cgr.dev/token?scope=repository:chainguard/{chainguard_pkg}:pull"
            token_response = requests.get(token_url)
            
            if token_response.status_code != 200:
                logger.warning(f"Failed to get Chainguard token: {token_response.status_code}")
                return None
            
            token = token_response.json().get('token')
            
            # Get tags from Chainguard registry
            url = f"https://cgr.dev/v2/chainguard/{chainguard_pkg}/tags/list"
            headers = {"Authorization": f"Bearer {token}"} if token else {}
            response = requests.get(url, headers=headers)
            
            if response.status_code == 200:
                tags = response.json().get('tags', [])
                if not tags:
                    logger.warning(f"No tags found for {chainguard_pkg} in Chainguard registry")
                    return None
                    
                # Filter out 'latest' and sort by version
                version_tags = [tag for tag in tags if tag != 'latest' and tag != 'latest-dev']
                if version_tags:
                    return {
                        'version': sorted(version_tags)[-1],
                        'all_versions': version_tags
                    }
                return {'version': 'latest', 'all_versions': ['latest']}
            elif response.status_code == 404:
                logger.warning(f"Package {chainguard_pkg} not found in Chainguard registry")
                return None
            else:
                logger.error(f"Failed to get version from Chainguard: {response.status_code}")
                return None
        except Exception as e:
            logger.error(f"Error while getting Chainguard version: {e}")
            return None
    
    def check_vulnerabilities(self, package_name, github_version):
        """
        Check if the specified version has any known vulnerabilities.
        This uses the GitHub Advisory Database API.
        """
        try:
            # Try with GitHub Advisory Database
            url = f"https://api.github.com/advisories?package={package_name}"
            response = requests.get(url)
            
            if response.status_code != 200:
                logger.warning(f"Failed to get vulnerability info: {response.status_code}")
                return "No vulns as per today."
            
            advisories = response.json()
            relevant_advisories = []
            
            for advisory in advisories:
                # Check if the advisory affects the version
                vulnerabilities = advisory.get('vulnerabilities', [])
                for vuln in vulnerabilities:
                    package = vuln.get('package', {})
                    if package.get('name', '').lower() == package_name.lower():
                        # Check if our version is in the affected range
                        # This is a simplified check, proper version comparison would be better
                        if github_version in vuln.get('vulnerable_version_range', ''):
                            relevant_advisories.append({
                                'cve_id': advisory.get('cve_id', 'N/A'),
                                'severity': advisory.get('severity', 'UNKNOWN'),
                                'summary': advisory.get('summary', '')
                            })
            
            if relevant_advisories:
                result = "Vulnerabilities found:\n"
                for adv in relevant_advisories:
                    result += f"- {adv['cve_id']} ({adv['severity']}): {adv['summary']}\n"
                return result.strip()
            else:
                return "No vulns as per today."
        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
            return "Error checking vulnerabilities."
    
    def download_package(self, repo_owner, repo_name, version):
        """Download the package to temporary directory."""
        if not self.tmp_dir:
            self.tmp_dir = tempfile.mkdtemp(prefix=f"{repo_name}-", dir="/tmp")
            logger.info(f"Created temporary directory: {self.tmp_dir}")
        
        try:
            download_path = os.path.join(self.tmp_dir, f"{repo_name}.tar.gz")
            url = f"https://github.com/{repo_owner}/{repo_name}/archive/refs/tags/{version}.tar.gz"
            
            logger.info(f"Downloading {url}...")
            response = requests.get(url, stream=True)
            
            if response.status_code != 200:
                logger.error(f"Failed to download package: {response.status_code}")
                return None
                
            with open(download_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            
            # Extract the archive
            extract_path = os.path.join(self.tmp_dir, f"{repo_name}-{version}")
            try:
                with tarfile.open(download_path) as tar:
                    # Check for any path traversal vulnerabilities
                    for member in tar.getmembers():
                        if member.name.startswith(('/')) or '..' in member.name:
                            logger.error(f"Suspicious path in tar: {member.name}")
                            return None
                    tar.extractall(path=self.tmp_dir)
                
                # The extracted folder typically has the version appended
                extracted_dirs = [d for d in os.listdir(self.tmp_dir) 
                                if os.path.isdir(os.path.join(self.tmp_dir, d))]
                
                if not extracted_dirs:
                    logger.error("No directories found after extraction")
                    return None
                
                # Use the first directory found
                extract_path = os.path.join(self.tmp_dir, extracted_dirs[0])
            except tarfile.ReadError:
                logger.error("Failed to extract tar.gz file")
                return None
            
            logger.info(f"Downloaded and extracted to {extract_path}")
            return extract_path
        except Exception as e:
            logger.error(f"Error while downloading package: {e}")
            return None
    
    def scan_with_trivy(self, package_path, package_name):
        """Scan the package with Trivy and save output."""
        output_file = f"{package_name}-trivy.txt"
        
        try:
            # Run Trivy scan on the downloaded package
            logger.info(f"Scanning {package_path} with Trivy...")
            command = ["trivy", "fs", "--severity", "HIGH,CRITICAL", package_path]
            
            result = subprocess.run(
                command,
                capture_output=True,
                text=True
            )
            
            # Save the output regardless of exit code
            with open(output_file, 'w') as f:
                f.write(result.stdout)
                if result.stderr:
                    f.write("\n\nERRORS:\n")
                    f.write(result.stderr)
            
            if result.returncode != 0 and result.returncode != 1:
                # Trivy returns 1 when vulnerabilities are found, which is expected
                logger.warning(f"Trivy scan returned non-zero exit code: {result.returncode}")
            
            logger.info(f"Scan completed. Results saved to {output_file}")
            return True
        except Exception as e:
            logger.error(f"Error while scanning with Trivy: {e}")
            with open(output_file, 'w') as f:
                f.write(f"Error scanning with Trivy: {str(e)}\n")
            return False
    
    def cleanup(self):
        """Clean up temporary files."""
        if self.tmp_dir and os.path.exists(self.tmp_dir):
            logger.info(f"Cleaning up temporary directory: {self.tmp_dir}")
            try:
                shutil.rmtree(self.tmp_dir, ignore_errors=True)
            except Exception as e:
                logger.error(f"Error cleaning up: {e}")
    
    def scan_package(self, package):
        """Scan a single package."""
        if '/' not in package:
            logger.error(f"Invalid package format: {package}. Use owner/repo format for GitHub packages.")
            return False
            
        repo_owner, repo_name = package.split('/', 1)
        
        # Get versions from different sources
        logger.info(f"Checking GitHub version for {repo_owner}/{repo_name}...")
        github_info = self.get_github_latest_version(repo_owner, repo_name)
        
        if not github_info or not github_info.get('version'):
            logger.error(f"Could not find GitHub version for {package}")
            return False
        
        github_version = github_info['version']
        
        logger.info(f"Checking ArtifactHub version for {repo_name}...")
        artifacthub_info = self.get_artifacthub_version(repo_name)
        
        logger.info(f"Checking Chainguard version for {repo_name}...")
        chainguard_info = self.get_chainguard_version(repo_name)
        
        # Display versions
        print(f"\n===== Package: {package} =====")
        print(f"GitHub Version: {github_version}")
        
        if artifacthub_info:
            print(f"ArtifactHub Version: {artifacthub_info.get('version', 'Not found')}")
        else:
            print("ArtifactHub Version: Not found")
        
        if chainguard_info:
            print(f"Chainguard Version: {chainguard_info.get('version', 'Not found')}")
        else:
            print("Chainguard Version: Not found")
        
        # Check for vulnerabilities
        vuln_status = self.check_vulnerabilities(repo_name, github_version)
        print(f"\nVulnerability Status: {vuln_status}")
        
        # Download and scan
        package_path = self.download_package(repo_owner, repo_name, github_version)
        if package_path:
            self.scan_with_trivy(package_path, repo_name)
        else:
            logger.error("Failed to download and extract package.")
            return False
        
        return True
    
    def run(self):
        """Run the scanner."""
        if not self.check_dependencies():
            return False
        
        try:
            if self.package_file:
                packages = self.parse_package_file()
                if not packages:
                    logger.error("No packages found in the package file.")
                    return False
                
                for package in packages:
                    self.scan_package(package)
                    # Create a new temp dir for each package
                    self.cleanup()
                    self.tmp_dir = None
            elif self.package:
                success = self.scan_package(self.package)
                if not success:
                    return False
            else:
                logger.error("No package specified.")
                return False
                
            return True
        except Exception as e:
            logger.error(f"Error running scanner: {e}")
            return False
        finally:
            self.cleanup()

def main():
    parser = argparse.ArgumentParser(description='Package Vulnerability Scanner')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-f', '--file', help='File containing packages to scan (one per line)')
    group.add_argument('-p', '--package', help='Package to scan (format: owner/repo for GitHub)')
    
    args = parser.parse_args()
    
    scanner = PackageScanner(package_file=args.file, package=args.package)
    success = scanner.run()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
```

## Usage Examples

### Scan a single package

```bash
python3 package_vulnerability_scanner.py -p jupyterhub/jupyterhub
```

### Scan multiple packages from a file

```bash
python3 package_vulnerability_scanner.py -f packages.txt
```

Where `packages.txt` contains one package per line:

```
# Example packages
jupyterhub/jupyterhub
kubernetes/kubernetes
# Add more packages as needed
```

## Features and Improvements

The script has been upgraded to:

1. **Check official sources only**:
   - GitHub API for latest official releases
   - ArtifactHub.io API for official package information
   - Chainguard registry for container image versions

2. **Vulnerability reporting**:
   - Reports vulnerabilities in the latest version from GitHub
   - Formats output as "No vulns as per today" if none found

3. **Download and scan improvements**:
   - Downloads the latest version to a temporary directory under /tmp
   - Extracts the package safely with path traversal protection
   - Scans with Trivy targeting HIGH and CRITICAL vulnerabilities
   - Outputs results to <package>-trivy.txt

4. **Cleanup process**:
   - Automatically removes temporary files after scanning
   - Uses proper temporary directory handling with error recovery

5. **Error handling**:
   - Comprehensive error handling for all API calls and file operations
   - Provides useful error messages and logging

## Dependencies

- Python 3.7+
- Trivy (must be installed and available in PATH)
- Python packages: requests

## Security Considerations

- The script includes measures to prevent path traversal attacks during tar extraction
- API tokens are handled securely and not persisted
- Error handling ensures temporary directories are always cleaned up

## Limitations

- The script currently only supports GitHub repositories as the primary source
- Vulnerability checking is basic and could be enhanced with better version range matching
- The ArtifactHub.io integration might need refinement for specific package types